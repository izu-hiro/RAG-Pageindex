
from openai import AsyncOpenAI
from getpass import getpass
from pageindex import PageIndexClient
from pypdf import PdfWriter
from os import listdir
from os.path import isfile, join
from time import sleep
from ollama import chat
from ollama import ChatResponse
from docx  import Document
import re

"""rag.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/izu-hiro/RAG-Pageindex/blob/main/rag.ipynb

Definindo a LLM
"""


def call_llm(input_content, system_prompt, deep_think = True, print_log = True):
    response: ChatResponse = chat(model='deepseek-r1:1.5b', messages=[
        {'role': 'system', 'content': system_prompt},
        {'role': 'user', 'content': input_content}
    ])
    response_text = response['message']['content']
    if print_log: print(response_text)

    think_texts = re.findall(r'<think>(.*?)</think>', response_text, flags=re.DOTALL)
    think_texts = "\n\n".join(think_texts).strip()
    clean_response = re.sub(r'<think>.*?</think>', '', response_text, flags=re.DOTALL).strip()

    return clean_response if not deep_think else (clean_response, think_texts)

#"""Conectando com o PageIndex"""

pi_client = PageIndexClient(api_key=input("Insira a chave API do Page Index: "))

#"""Contexto utilizado na geração da resposta"""

documentos = ['documentos/'+f for f in listdir('Documents') if isfile(join('documentos', f))]

merger = PdfWriter()
for documento in documentos:
    merger.append(documento)
merger.write("documentoUnido.pdf")
merger.close()

#"""Enviar arquivo e pegar o ID"""

op = 2
while not op in (0, 1):
    op = int(input("Insira 0 para subir um novo documento ou 1 para inserir a chave de um documento existente: "))
if op == 0:
    result = pi_client.submit_document("./documentoUnido.pdf")
    doc_id = result["doc_id"]
else:
    doc_id = input("insira o ID do documento: ")


# Get OCR results in page format (default)

try:
    ocr_result = pi_client.get_ocr(doc_id)
    while True:
        if ocr_result.get("status") == "completed":
            print("OCR Results:", ocr_result.get("result"))
            break
        else:
            sleep(5)
except Exception as e:
    print(f"OCR indisponivel ou nao suportado")
'''

# Get OCR results in node format
ocr_result = pi_client.get_ocr(doc_id, format="node")
if ocr_result.get("status") == "completed":
    print("OCR Results:", ocr_result.get("result"))

 # Get OCR results in raw format (concatenated markdown)
ocr_result = pi_client.get_ocr(doc_id, format="raw")
if ocr_result.get("status") == "completed":
    print("Raw Markdown:", ocr_result.get("result"))
'''

tree_result = pi_client.get_tree(doc_id)
while True:
    if tree_result.get("status") == "completed":
        print("PageIndex Tree Structure:", tree_result.get("result"))
        break
    else:
        sleep(5)

#"""Retrieval"""

def retrieval(query):
    while True:
        if pi_client.is_retrieval_ready(doc_id):
            retrieval = pi_client.submit_query(doc_id, query)
            retrieval_id = retrieval['retrieval_id']
            break
        else:
            print("Document is not ready for retrieval yet")
            sleep(5)

    while True:
        retrieval_result = pi_client.get_retrieval(retrieval_id)
        if retrieval_result.get("status") == "completed":
            return retrieval_result.get('retrieved_nodes')
        sleep(1)

print("### INICIANDO DEMONSTRAÇÃO ###\n")

# Pergunta original
original_query = input("Digite o que deseja buscar: ")

multi_query_prompt = """
Você é um assistente especializado em reformular perguntas para recuperação de informações.
Dada uma pergunta original, gere de 3 a 5 variações semanticamente diferentes,
mantendo o mesmo significado central. Essas variações devem ajudar a encontrar
respostas relevantes mesmo que a formulação da pergunta original não seja exata.
Liste cada reformulação em uma nova linha.
"""

print("PASSO 1: Gerando Reformulações ")

multi_queries_text = call_llm(original_query, multi_query_prompt, deep_think=False)

if isinstance(multi_queries_text, tuple):
    multi_queries_text = multi_queries_text[0]

multi_queries = [q.strip() for q in multi_queries_text.splitlines() if q.strip()]

print("Consultas Geradas:")
for q in multi_queries:
    print("-", q)

print("\n PASSO 2: Recuperando contexto ")
all_results = []
for q in multi_queries:
    context = retrieval(q)
    all_results.extend(context)

# Remove duplicados 
unique_context = list({str(node): node for node in all_results}.values())
print(f"Foram recuperados {len(unique_context)} trechos únicos do documento.")

print("PASSO 2.1: Carregando legislações fixas (ETP e TR)")
def ler_docx_para_texto(caminho, limpar_texto):
    try:
        doc = Document(caminho)
        partes = []

        # le paragrafo
        for p in doc.paragraphs:
            if p.text.strip():
                partes.append(p.text.strip())

        # le tabelas 
        for table in doc.tables:
            for row in table.rows:
                linha = " | ".join([cell.text.strip() for cell in row.cells if cell.text.strip()])
                if linha:
                    partes.append(linha)

        texto_final = "\n".join(partes)
        return limpar_texto(texto_final)

    except Exception as e:
        print(f"Erro ao ler {caminho}: {e}")
        return f"(Não foi possível ler o arquivo {caminho})"

def sem_limpeza(texto):
   return texto

lei1 = ler_docx_para_texto("MODELO_DE_ESTUDO_TECNICO_PRELIMINAR_GERAL.docx", sem_limpeza)
lei2 = ler_docx_para_texto("MODELO_DE_TERMO_DE_REFERENCIA_GERAL.docx", sem_limpeza)

# Combina o contexto PageIndex com as legislações 
context = f"""
### Trechos recuperados dos documentos técnicos:
{unique_context}

---

### Modelos legais aplicáveis (Lei 14.133/2021):
#### Estudo Técnico Preliminar (ETP)
{lei1}

#### Termo de Referência (TR)
{lei2}
---
"""

# Prompt final 

final_answer_prompt = f"""
Você é um assistente técnico especializado em análise documental para licitações,
contratações públicas e serviços administrativos.

Sua função é interpretar o conteúdo retornado pela busca e responder à consulta abaixo
de forma técnica, objetiva e fundamentada.

Regras:
1. Responda apenas com base nas informações do documento recuperado.
2. Se o contexto não contiver resposta suficiente, informe isso claramente
3. Use linguagem formal e precisa, como em um parecer técnico.
4. Não invente nem adicione informações fora do contexto retornado.

### Contexto dos documentos:
{context}

---
### Consulta do Usuário:
{original_query}
---

### Resposta:
"""

print(" PASSO 3: Gerando a Resposta Final ")

final_answer = call_llm(original_query, final_answer_prompt)
print("Resposta Gerada:\n")
print(final_answer)
